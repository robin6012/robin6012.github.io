<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="介紹本文檔給出了構成主要 Python 發行版中標準函式庫的 Python 程式碼的編碼約定。請參閱隨附的資訊 PEP，描述Python 的 C 實作中的 C 程式碼的樣式指南。 本文檔和PEP 257（文檔字串約定）改編自 Guido 的原始 Python 樣式指南文章，並添加了 Barry 的樣式指南[2]中的一些內容。 隨著時間的推移，隨著附加約定的確定以及過去的約定因語言本身的變化而變得過">
<meta property="og:type" content="article">
<meta property="og:title" content="PEP 8 – Python 程式碼風格指南">
<meta property="og:url" content="http://example.com/2024/07/12/python-pep8/index.html">
<meta property="og:site_name" content="Robin blog">
<meta property="og:description" content="介紹本文檔給出了構成主要 Python 發行版中標準函式庫的 Python 程式碼的編碼約定。請參閱隨附的資訊 PEP，描述Python 的 C 實作中的 C 程式碼的樣式指南。 本文檔和PEP 257（文檔字串約定）改編自 Guido 的原始 Python 樣式指南文章，並添加了 Barry 的樣式指南[2]中的一些內容。 隨著時間的推移，隨著附加約定的確定以及過去的約定因語言本身的變化而變得過">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-12T01:57:18.000Z">
<meta property="article:modified_time" content="2024-07-15T02:45:09.353Z">
<meta property="article:author" content="Robin Cheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/07/12/python-pep8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>PEP 8 – Python 程式碼風格指南 | Robin blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Robin blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/12/python-pep8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robin Cheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Robin blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PEP 8 – Python 程式碼風格指南
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 09:57:18" itemprop="dateCreated datePublished" datetime="2024-07-12T09:57:18+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-15 10:45:09" itemprop="dateModified" datetime="2024-07-15T10:45:09+08:00">2024-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>本文檔給出了構成主要 Python 發行版中標準函式庫的 Python 程式碼的編碼約定。請參閱隨附的資訊 PEP，描述<a class="pep reference internal" target="_blank" rel="noopener" href="https://peps.python.org/pep-0007/" title="PEP 7 – Style Guide for C Code">Python 的 C 實作中的 C 程式碼的樣式指南。</a></p>
<p>本文檔和PEP 257（文檔字串約定）改編自 Guido 的原始 Python 樣式指南文章，並添加了 Barry 的樣式指南[2]中的一些內容。</p>
<p>隨著時間的推移，隨著附加約定的確定以及過去的約定因語言本身的變化而變得過時，這種風格指南也在不斷發展。</p>
<p>許多項目都有自己的程式設計風格指南。如果發生任何衝突，則此類特定於專案的指南優先適用於該專案。</p>
<h1 id="愚蠢的一致性是小頭腦的惡魔"><a href="#愚蠢的一致性是小頭腦的惡魔" class="headerlink" title="愚蠢的一致性是小頭腦的惡魔"></a>愚蠢的一致性是小頭腦的惡魔</h1><p>Guido 的重要見解之一是，程式碼的讀取次數遠多於編寫次數。此處提供的指南旨在提高程式碼的可讀性並使其在各種 Python 程式碼中保持一致。正如PEP 20所說，「可讀性很重要」。</p>
<p>風格指南是關於一致性的。與本風格指南的一致性很重要。專案內的一致性更為重要。一個模組或功能內的一致性是最重要的。</p>
<p>然而，知道何時要不一致——有時風格指南的建議並不適用。如有疑問，請運用您的最佳判斷。查看其他範例並決定哪個看起來最好。請隨時詢問！</p>
<p>特別是：不要僅僅為了遵守此 PEP 而破壞向後相容性！</p>
<p>忽略特定準則的其他一些充分理由：</p>
<p>應用指南會降低程式碼的可讀性，即使對於習慣閱讀遵循此 PEP 的程式碼的人也是如此。<br>與周圍也破壞它的程式碼保持一致（可能是出於歷史原因）——儘管這也是清理別人混亂的機會（以真正的 XP 風格）。<br>因為相關程式碼早於指南的引入，並且沒有其他原因需要修改該程式碼。<br>當程式碼需要與不支援樣式指南推薦的功能的舊版 Python 保持相容時。</p>
<h1 id="程式碼佈局"><a href="#程式碼佈局" class="headerlink" title="程式碼佈局"></a>程式碼佈局</h1><h2 id="縮排"><a href="#縮排" class="headerlink" title="縮排"></a>縮排</h2><p>每個縮排等級使用 4 個空格。</p>
<p>連續行應該使用 Python 的隱式行連接在圓括號、方括號和大括號內垂直對齊包裹的元素，或使用懸掛縮排 [1]。使用懸掛縮排時應考慮以下事項：第一行不應該有參數，並且應該使用進一步的縮進來清楚地將其自身區分為連續行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"></span><br><span class="line"># Aligned with opening delimiter.</span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"># Add <span class="number">4</span> spaces (an extra level of indentation) to distinguish arguments from the rest.</span><br><span class="line">def long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four):</span><br><span class="line">    print(var_one)</span><br><span class="line"></span><br><span class="line"># Hanging indents should add a level.</span><br><span class="line">foo = long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"></span><br><span class="line"># Arguments on first line forbidden when not using vertical alignment.</span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line"># Further indentation required as indentation is not distinguishable.</span><br><span class="line">def long_function_name(</span><br><span class="line">    var_one, var_two, var_three,</span><br><span class="line">    var_four):</span><br><span class="line">    print(var_one)</span><br><span class="line">```    </span><br><span class="line">對於連續行，<span class="number">4</span> 空格規則是可選的。</span><br><span class="line"></span><br><span class="line">選修的：</span><br><span class="line">```c</span><br><span class="line"># Hanging indents *may* be indented to other than <span class="number">4</span> spaces.</span><br><span class="line">foo = long_function_name(</span><br><span class="line">  var_one, var_two,</span><br><span class="line">  var_three, var_four)</span><br><span class="line">```  </span><br><span class="line">當 - 語句的條件部分<span class="keyword">if</span>足夠長，需要跨多行編寫時，值得注意的是，兩個字元關鍵字（即<span class="keyword">if</span>）、單個空格和左括號的組合會創建一個自然的 <span class="number">4</span>-多行條件語句後續行的空格縮排。這可能會與嵌套在 - 語句內的縮排程式碼套件產生視覺衝突<span class="keyword">if</span>，該程式碼套件自然也會縮排 <span class="number">4</span> 個空格。對於如何（或是否）進一步在視覺上將這些條件行與<span class="keyword">if</span>- 語句內的嵌套套件區分開來，此 PEP 沒有採取明確的立場。在這種情況下可接受的選擇包括但不限於：</span><br><span class="line">```c</span><br><span class="line"># No extra indentation.</span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing and</span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"># Add a comment, which will provide some distinction in editors</span><br><span class="line"><span class="meta"># supporting syntax highlighting.</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing and</span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    # Since both conditions are <span class="literal">true</span>, we can frobnicate.</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"># Add some extra indentation on the conditional continuation line.</span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">        and that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line">```    </span><br><span class="line">（另請參閱下面關於是否在二元運算子之前或之後中斷的討論。）</span><br><span class="line"></span><br><span class="line">多行結構上的右大括號/方括號/圓括號可以排列在列表最後一行的第一個非空白字元下，如下所示：</span><br><span class="line">```c</span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    ]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">```    </span><br><span class="line">或者它可以排列在開始多行結構的行的第一個字元下，如下所示：</span><br><span class="line">```c</span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="製表符還是空格？"><a href="#製表符還是空格？" class="headerlink" title="製表符還是空格？"></a>製表符還是空格？</h2><p>空格是首選的縮排方法。</p>
<p>製表符應僅用於與已使用製表符縮排的代碼保持一致。</p>
<p>Python 不允許混合製表符和空格進行縮排。</p>
<h2 id="最大線路長度"><a href="#最大線路長度" class="headerlink" title="最大線路長度"></a>最大線路長度</h2><p>將所有行限制為最多 79 個字元。</p>
<p>對於結構限制較少（文件字串或註解）的流動長文字區塊，行長度應限制為 72 個字元。</p>
<p>限制所需的編輯器視窗寬度可以並排開啟多個文件，並且在使用在相鄰列中顯示兩個版本的程式碼審查工具時效果很好。</p>
<p>大多數工具中的預設包裝會破壞程式碼的視覺結構，使其更難以理解。選擇這些限制是為了避免在視窗寬度設定為 80 的編輯器中進行換行，即使工具在換行時在最後一列中放置了標記符號。一些基於網路的工具可能根本不提供動態換行。</p>
<p>有些團隊強烈喜歡更長的線路。對於專門或主要由可以就此問題達成一致的團隊維護的代碼，可以將行長度限制增加到 99 個字符，前提是註釋和文檔字符串仍以 72 個字符換行。</p>
<p>Python 標準函式庫比較保守，要求將行數限制為 79 個字元（文件字串&#x2F;註解限制為 72 個）。</p>
<p>換行長行的首選方法是在圓括號、方括號和大括號內使用 Python 的隱式續行。將表達式括在括號中，可以將長行分成多行。應優先使用這些內容而不是使用反斜線來繼續行。</p>
<p>反斜線有時仍然是合適的。例如，with在 Python 3.10 之前，長的多語句不能使用隱式延續，因此在這種情況下反斜線是可以接受的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with <span class="title function_">open</span><span class="params">(<span class="string">&#x27;/path/to/some/file/you/want/to/read&#x27;</span>)</span> as file_1, \</span><br><span class="line">     <span class="title function_">open</span><span class="params">(<span class="string">&#x27;/path/to/some/file/being/written&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span> as file_2:</span><br><span class="line">    file_2.<span class="title function_">write</span><span class="params">(file_1.read())</span></span><br></pre></td></tr></table></figure>
<p>（有關多行 if語句縮排的進一步思考，請參閱前面關於多行 if 語句的討論with。）</p>
<p>另一個這樣的情況是assert語句。</p>
<p>確保適當縮排續行。</p>
<h2 id="應該在二元運算子之前還是之後換行？"><a href="#應該在二元運算子之前還是之後換行？" class="headerlink" title="應該在二元運算子之前還是之後換行？"></a>應該在二元運算子之前還是之後換行？</h2><p>幾十年來，推薦的風格是在二元運算子之後中斷。但這會以兩種方式損害可讀性：運算符往往會分散在螢幕上的不同列中，並且每個運算符都會從其運算元移到上一行。在這裡，眼睛必須做額外的工作來分辨哪些項目被添加，哪些項目被減去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"><span class="meta"># operators sit far away from their operands</span></span><br><span class="line">income = (gross_wages +</span><br><span class="line">          taxable_interest +</span><br><span class="line">          (dividends - qualified_dividends) -</span><br><span class="line">          ira_deduction -</span><br><span class="line">          student_loan_interest)</span><br></pre></td></tr></table></figure>
<p>為了解決這個可讀性問題，數學家和他們的出版商遵循相反的慣例。 Donald Knuth 在他的電腦和排版系列中解釋了傳統規則：「雖然段落中的公式總是在二元運算和關係之後中斷，但顯示的公式總是在二元運算之前中斷」[3]。</p>
<p>遵循數學傳統通常會產生更具可讀性的程式碼：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="meta"># easy to match operators with operands</span></span><br><span class="line">income = (gross_wages</span><br><span class="line">          + taxable_interest</span><br><span class="line">          + (dividends - qualified_dividends)</span><br><span class="line">          - ira_deduction</span><br><span class="line">          - student_loan_interest)</span><br></pre></td></tr></table></figure>
<p>在 Python 程式碼中，只要約定在本地一致，就允許在二元運算子之前或之後中斷。對於新程式碼，建議採用 Knuth 風格。</p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>用兩個空白行包圍頂層函數和類別定義。</p>
<p>類別內的方法定義由一個空白行包圍。</p>
<p>可以（謹慎地）使用額外的空白行來分隔相關函數組。在一堆相關的單行程式碼（例如一組虛擬實作）之間可以省略空白行。</p>
<p>在函數中謹慎使用空白行來指示邏輯部分。</p>
<p>Python 接受 control-L（即 ^L）換頁符號作為空格；許多工具將這些字元視為頁面分隔符，因此您可以使用它們來分隔文件的相關部分的頁面。請注意，某些編輯器和基於 Web 的程式碼檢視器可能無法將 control-L 識別為換頁符，並會在其位置顯示另一個字形。</p>
<h2 id="原始檔編碼"><a href="#原始檔編碼" class="headerlink" title="原始檔編碼"></a>原始檔編碼</h2><p>核心 Python 發行版中的程式碼應始終使用 UTF-8，且不應具有編碼聲明。</p>
<p>在標準庫中，非 UTF-8 編碼只能用於測試目的。謹慎使用非 ASCII 字符，最好僅用於表示地點和人名。如果使用非 ASCII 字元作為數據，請避免使用雜訊的 Unicode 字符，例如 z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘ 和位元組順序標記。</p>
<p>Python 標準庫中的所有標識符必須使用純 ASCII 標識符，並且應盡可能使用英語單字（在許多情況下，使用非英語的縮寫和技術術語）。</p>
<p>鼓勵擁有全球受眾的開源專案採取類似的政策。</p>
<h2 id="進口"><a href="#進口" class="headerlink" title="進口"></a>進口</h2><ul>
<li>導入通常應該在單獨的行上：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">import os</span><br><span class="line">import sys</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line">import sys, os</span><br></pre></td></tr></table></figure>
不過這樣說也沒關係：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">from subprocess import Popen, PIPE</span><br></pre></td></tr></table></figure></li>
<li>導入始終放在文件的頂部，緊接在任何模組註解和文件字串之後，以及模組全域變數和常數之前。<br>導入應依下列順序分組：</li>
</ul>
<ol>
<li>標準庫導入。</li>
<li>相關第三方進口。</li>
<li>本機應用程式&#x2F;庫特定的導入。<br>您應該在每組匯入之間放置一個空白行。</li>
</ol>
<ul>
<li>建議絕對導入，因為如果導入系統配置不正確（例如當包內的目錄以 結尾時sys.path），它們通常更具可讀性並且往往表現更好（或至少給出更好的錯誤訊息）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import mypkg.sibling</span><br><span class="line">from mypkg import sibling</span><br><span class="line">from mypkg.sibling import example</span><br></pre></td></tr></table></figure>
然而，明確相對導入是絕對導入的可接受替代方案，特別是在處理複雜的套件佈局時，使用絕對導入會不必要地冗長：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import sibling</span><br><span class="line">from .sibling import example</span><br></pre></td></tr></table></figure>
標準庫程式碼應避免複雜的套件佈局並始終使用絕對導入。</li>
</ul>
<p>當從包含類別的模組匯入類別時，通常可以這樣拼寫：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from myclass import MyClass</span><br><span class="line">from foo.bar.yourclass import YourClass</span><br></pre></td></tr></table></figure>
<p>如果這種拼字導致本地名稱衝突，請明確拼寫它們：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import myclass</span><br><span class="line">import foo.bar.yourclass</span><br></pre></td></tr></table></figure>
<p>並使用<code>myclass.MyClass</code>和<code>foo.bar.yourclass.YourClass</code>。</p>
<ul>
<li>應避免通配符導入 ( )，因為它們使命名空間中存在哪些名稱變得不清楚，從而使讀者和許多自動化工具感到困惑。通配符導入有一個合理的用例，即重新發佈內部介面作為公共 API 的一部分（例如，使用可選加速器模組中的定義覆蓋介面的純 Python 實現，以及哪些定義將被覆蓋）提前不知道被覆蓋）。<code>from &lt;module&gt; import *</code><br>以這種方式重新發布名稱時，以下有關公共和內部介面的準則仍然適用。</li>
</ul>
<h2 id="模組等級-Dunder-名稱"><a href="#模組等級-Dunder-名稱" class="headerlink" title="模組等級 Dunder 名稱"></a>模組等級 Dunder 名稱</h2><p>模組級「dunders」（即帶有兩個前導和兩個尾隨下劃線的名稱），例如__all__、__author__、__version__等應放置在模組文件字串之後，但在除 導入之外的任何導入語句之前。 Python 要求 future-imports 必須出現在模組中除文檔字串之外的任何其他程式碼之前：from <strong>future</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;This is the example module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module does stuff.</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">from __future__ import barry_as_FLUFL</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Cardinal Biggles&#x27;</span></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br></pre></td></tr></table></figure>

<h1 id="字串引號"><a href="#字串引號" class="headerlink" title="字串引號"></a>字串引號</h1><p>在Python中，單引號字串和雙引號字串是相同的。本 PEP 並未對此提出建議。選擇一個規則並遵守它。但是，當字串包含單引號或雙引號字元時，請使用另一個以避免字串中出現反斜線。它提高了可讀性。</p>
<p>對於三引號字串，請始終使用雙引號字符，以與PEP 257中的文件字串約定保持一致。</p>
<h1 id="表達式和語句中的空格"><a href="#表達式和語句中的空格" class="headerlink" title="表達式和語句中的空格"></a>表達式和語句中的空格</h1><h2 id="討厭的事"><a href="#討厭的事" class="headerlink" title="討厭的事"></a>討厭的事</h2><p>在以下情況下避免使用多餘的空格：</p>
<ul>
<li>緊鄰圓括號、方括號或大括號內：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</span><br><span class="line"># Wrong:</span><br><span class="line">spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125; )</span><br></pre></td></tr></table></figure></li>
<li>在尾隨逗號和後面的右括號之間：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">foo = (<span class="number">0</span>,)</span><br><span class="line"># Wrong:</span><br><span class="line">bar = (<span class="number">0</span>, )</span><br></pre></td></tr></table></figure></li>
<li>緊接在逗號、分號或冒號之前：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span>: print(x, y); x, y = y, x</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span> : print(x , y) ; x , y = y , x</span><br></pre></td></tr></table></figure></li>
<li>但是，在切片中，冒號的作用類似於二元運算符，並且兩側應具有相同的數量（將其視為優先順序最低的運算符）。在擴展切片中，兩個冒號必須施加相同的間距。例外：當省略切片參數時，空格也被省略：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">ham[lower:upper], ham[lower:upper:], ham[lower::step]</span><br><span class="line">ham[lower+offset : upper+offset]</span><br><span class="line">ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]</span><br><span class="line">ham[lower + offset : upper + offset]</span><br><span class="line"># Wrong:</span><br><span class="line">ham[lower + offset:upper + offset]</span><br><span class="line">ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>]</span><br><span class="line">ham[lower : : step]</span><br><span class="line">ham[ : upper]</span><br></pre></td></tr></table></figure></li>
<li>緊接在開始函數呼叫的參數列表的左括號之前：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">spam(<span class="number">1</span>)</span><br><span class="line"># Wrong:</span><br><span class="line">spam (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li>緊接在開始索引或切片的左括號之前：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">dct[<span class="string">&#x27;key&#x27;</span>] = lst[index]</span><br><span class="line"># Wrong:</span><br><span class="line">dct [<span class="string">&#x27;key&#x27;</span>] = lst [index]</span><br></pre></td></tr></table></figure></li>
<li>賦值（或其他）運算子周圍有多個空格以將其與另一個運算子對齊：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">long_variable = <span class="number">3</span></span><br><span class="line"># Wrong:</span><br><span class="line">x             = <span class="number">1</span></span><br><span class="line">y             = <span class="number">2</span></span><br><span class="line">long_variable = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他建議"><a href="#其他建議" class="headerlink" title="其他建議"></a>其他建議</h2><ul>
<li>避免在任何地方出現尾隨空格。因為它通常是不可見的，所以可能會令人困惑：例如，反斜線後跟空格和換行符不算是行繼續標記。一些編輯器不保留它，並且許多項目（例如 CPython 本身）都有拒絕它的預提交掛鉤。<br>總是在這些二元運算子兩側加上一個空格：賦值 ( <code>=</code>)、擴展賦值（<code>+=</code>等<code>-=</code> ）、比較（<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, , <code>&gt;=</code>, <code>in</code>, , ），布林值（, , ）。<code>not inisis notandorno</code>t</li>
<li>如果使用具有不同優先權的運算符，請考慮在優先權最低的運算子周圍新增空格。使用你自己的判斷；但是，切勿使用多個空格，且二元運算子兩側始終具有相同數量的空格：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">submitted += <span class="number">1</span></span><br><span class="line">x = x*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x*x + y*y</span><br><span class="line">c = (a+b) * (a-b)</span><br><span class="line"># Wrong:</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">submitted +=<span class="number">1</span></span><br><span class="line">x = x * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x * x + y * y</span><br><span class="line">c = (a + b) * (a - b)</span><br></pre></td></tr></table></figure></li>
<li>函數註釋應使用冒號的正常規則，並且-&gt;箭頭周圍始終有空格（如果存在）。 （有關函數註釋的更多信息，請參閱 下面的函數註釋。）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(input: AnyStr)</span>: ...</span><br><span class="line">def <span class="title function_">munge</span><span class="params">()</span> -&gt; PosInt: ...</span><br><span class="line"># Wrong:</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(input:AnyStr)</span>: ...</span><br><span class="line">def <span class="title function_">munge</span><span class="params">()</span>-&gt;PosInt: ...</span><br></pre></td></tr></table></figure></li>
<li><code>=</code>當用於指示關鍵字參數或用於指示 未註釋的函數參數的預設值時，請勿在符號周圍使用空格：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">def <span class="title function_">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">magic</span><span class="params">(r=real, i=imag)</span></span><br><span class="line"># Wrong:</span><br><span class="line">def <span class="title function_">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">magic</span><span class="params">(r = real, i = imag)</span></span><br></pre></td></tr></table></figure>
但是，當將參數註釋與預設值組合時，請在&#x3D;符號周圍使用空格：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(sep: AnyStr = None)</span>: ...</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(input: AnyStr, sep: AnyStr = None, limit=<span class="number">1000</span>)</span>: ...</span><br><span class="line"># Wrong:</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(input: AnyStr=None)</span>: ...</span><br><span class="line">def <span class="title function_">munge</span><span class="params">(input: AnyStr, limit = <span class="number">1000</span>)</span>: ...</span><br></pre></td></tr></table></figure></li>
<li>通常不鼓勵複合語句（同一行上的多個語句）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>:</span><br><span class="line">    do_blah_thing()</span><br><span class="line">do_one()</span><br><span class="line">do_two()</span><br><span class="line">do_three()</span><br></pre></td></tr></table></figure>
而不是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line">do_one(); do_two(); do_three()</span><br></pre></td></tr></table></figure></li>
<li>雖然有時可以將 if&#x2F;for&#x2F;while 與一個小主體放在同一行，但切勿對多子句語句這樣做。還要避免折疊這麼長的線！<br>而不是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">for</span> x in lst: total += x</span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">10</span>: t = delay()</span><br></pre></td></tr></table></figure>
當然不：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">else</span>: do_non_blah_thing()</span><br><span class="line"></span><br><span class="line">try: something()</span><br><span class="line">finally: cleanup()</span><br><span class="line"></span><br><span class="line">do_one(); do_two(); do_three(<span class="type">long</span>, argument,</span><br><span class="line">                             <span class="built_in">list</span>, like, this)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: one(); two(); three()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="何時使用尾隨逗號"><a href="#何時使用尾隨逗號" class="headerlink" title="何時使用尾隨逗號"></a>何時使用尾隨逗號</h1><p>尾隨逗號通常是可選的，但在創建一個元素的元組時它們是強制性的。為了清楚起見，建議將後者括在（技術上多餘的）括號中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">FILES = (<span class="string">&#x27;setup.cfg&#x27;</span>,)</span><br><span class="line"># Wrong:</span><br><span class="line">FILES = <span class="string">&#x27;setup.cfg&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p>當尾隨逗號是多餘的時，當使用版本控制系統時，當值、參數或導入項目的清單預計會隨著時間的推移而擴展時，它們通常很有用。此模式是將每個值（等）單獨放在一行上，始終添加尾隨逗號，並在下一行添加右括號&#x2F;方括號&#x2F;大括號。然而，在與結束分隔符號相同的行上使用尾隨逗號是沒有意義的（除了上述單例元組的情況）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">FILES = [</span><br><span class="line">    <span class="string">&#x27;setup.cfg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tox.ini&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">initialize(FILES,</span><br><span class="line">           error=True,</span><br><span class="line">           )</span><br><span class="line"># Wrong:</span><br><span class="line">FILES = [<span class="string">&#x27;setup.cfg&#x27;</span>, <span class="string">&#x27;tox.ini&#x27;</span>,]</span><br><span class="line">initialize(FILES, error=True,)</span><br></pre></td></tr></table></figure>

<h1 id="評論"><a href="#評論" class="headerlink" title="評論"></a>評論</h1><p>與程式碼相矛盾的註解比沒有註解更糟糕。當程式碼更改時，始終優先考慮使註釋保持最新！</p>
<p>註釋應該是完整的句子。第一個單字應大寫，除非它是以小寫字母開頭的識別符（切勿更改標識符的大小寫！）。</p>
<p>區塊註釋通常由一個或多個由完整句子組成的段落組成，每個句子以句號結尾。</p>
<p>在多句註釋中，除了最後一句之外，您應該在句末句號後面使用一兩個空格。</p>
<p>確保您的評論對於使用您所寫語言的其他使用者來說清晰且易於理解。</p>
<p>來自非英語國家的 Python 程式設計師：請用英語寫下您的註釋，除非您 120% 確定程式碼永遠不會被不會說您的語言的人閱讀。</p>
<h2 id="阻止評論"><a href="#阻止評論" class="headerlink" title="阻止評論"></a>阻止評論</h2><p>區塊註解通常適用於其後面的部分（或全部）程式碼，並且縮排到與該程式碼相同的層級。區塊註解的每一行都以 和#一個空格開頭（除非它是註解內的縮排文字）。</p>
<p>塊註釋內的段落由包含單一#.</p>
<h2 id="內嵌評論"><a href="#內嵌評論" class="headerlink" title="內嵌評論"></a>內嵌評論</h2><p>謹慎使用內聯註釋。</p>
<p>內嵌註解是與語句位於同一行的註解。內嵌註釋與語句之間應至少以兩個空格分隔。它們應該以 # 和一個空格開頭。</p>
<p>內嵌註釋是不必要的，而且如果它們陳述了顯而易見的內容，實際上會分散注意力。不要這樣做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 # Increment x</span><br></pre></td></tr></table></figure>
<p>但有時，這很有用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 # Compensate <span class="keyword">for</span> border</span><br></pre></td></tr></table></figure>

<h2 id="文件字串"><a href="#文件字串" class="headerlink" title="文件字串"></a>文件字串</h2><p>編寫良好文檔字串（又稱「文檔字串」）的約定在PEP 257中永垂不朽。</p>
<p>為所有公共模組、函數、類別和方法編寫文件字串。對於非公共方法來說，文檔字串不是必需的，但您應該有一條註釋來描述該方法的用途。此註解應出現在該def行之後。<br>PEP 257描述了良好的文件字串約定。請注意，最重要的是，”””結束多行文件字串的 應該單獨佔一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;Return a foobang</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optional plotz says to frobnicate the bizbaz first.</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>對於單行文檔字串，請將結尾保持”””在同一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;Return an ex-parrot.&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="命名約定"><a href="#命名約定" class="headerlink" title="命名約定"></a>命名約定</h1><p>Python 函式庫的命名約定有點混亂，因此我們永遠無法使其完全一致——儘管如此，以下是目前推薦的命名標準。新的模組和套件（包括第三方框架）應按照這些標準編寫，但如果現有庫具有不同的風格，則首選內部一致性。</p>
<h2 id="壓倒一切的原則"><a href="#壓倒一切的原則" class="headerlink" title="壓倒一切的原則"></a>壓倒一切的原則</h2><p>作為 API 公共部分對使用者可見的名稱應遵循反映用法而不是實現的約定。</p>
<h2 id="描述性：命名風格"><a href="#描述性：命名風格" class="headerlink" title="描述性：命名風格"></a>描述性：命名風格</h2><p>有很多不同的命名風格。它有助於識別正在使用的命名樣式，而與它們的用途無關。</p>
<p>通常區分以下命名風格：</p>
<ul>
<li><p><code>b</code>（單個小寫字母）</p>
</li>
<li><p><code>B</code>（單一大寫字母）</p>
</li>
<li><p><code>lowercase</code></p>
</li>
<li><p><code>lower_case_with_underscores</code></p>
</li>
<li><p><code>UPPERCASE</code></p>
</li>
<li><p><code>UPPER_CASE_WITH_UNDERSCORES</code></p>
</li>
<li><p><code>CapitalizedWords</code>（或 CapWords，或 CamelCase——如此命名是因為它的字母看起來凹凸不平[4]）。有時也稱為 StudlyCaps。<br>注意：在 CapWords 中使用縮寫時，請將縮寫的所有字母大寫。因此 HTTPServerError 比 HttpServerError 更好。</p>
</li>
<li><p><code>mixedCase</code>（與 CatalizedWords 的區別在於首字母小寫字元！）</p>
</li>
<li><p><code>Capitalized_Words_With_Underscores</code>（醜的！）<br>還有一種使用簡短的唯一前綴將相關名稱分組在一起的風格。這在 Python 中用得不多，但為了完整性還是提到了。例如，該<code>os.stat()</code>函數傳回一個元組，其項目傳統上具有諸如<code>st_mode</code>、 <code>st_size</code>等名稱<code>st_mtime</code>。 （這樣做是為了強調與 POSIX 系統調用結構體字段的對應關係，這有助於程式設計師熟悉這一點。）</p>
</li>
</ul>
<p>X11 函式庫在其所有公用函數中使用前導 X。在Python中，這種風格通常被認為是不必要的，因為屬性和方法名稱以物件為前綴，函數名稱以模組名稱為前綴。</p>
<p>此外，還可以識別以下使用前導或尾隨下劃線的特殊形式（這些形式通常可以與任何大小寫約定結合使用）：</p>
<ul>
<li><code>_single_leading_underscore</code>：「內部使用」指標較弱。例如，不匯入名稱以下劃線開頭的物件。<code>from M import *</code></li>
<li><code>single_trailing_underscore_</code>：按慣例使用以避免與Python關鍵字衝突，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkinter.Toplevel(master, class_=<span class="string">&#x27;ClassName&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>__double_leading_underscore</code>：命名類別屬性時，呼叫名稱修改（在類別 FooBar 中，<code>__boo</code>變成 <code>_FooBar__boo</code>；見下文）。</li>
<li><code>__double_leading_and_trailing_underscore__</code>：存在於使用者控制的命名空間中的「神奇」物件或屬性。例如<code>__init__</code>，<code>__import__</code>或<code>__file__</code>。永遠不要發明這樣的名字；僅按照記錄使用它們。</li>
</ul>
<h2 id="規定性：命名約定"><a href="#規定性：命名約定" class="headerlink" title="規定性：命名約定"></a>規定性：命名約定</h2><h3 id="應避免使用的名字"><a href="#應避免使用的名字" class="headerlink" title="應避免使用的名字"></a>應避免使用的名字</h3><p>切勿使用字元“l”（小寫字母 el）、“O”（大寫字母 oh）或“I”（大寫字母 eye）作為單字元變數名稱。</p>
<p>在某些字體中，這些字元與數字 1 和 0 無法區分。想要使用“l”時，請改用“L”。</p>
<h3 id="ASCII-相容性"><a href="#ASCII-相容性" class="headerlink" title="ASCII 相容性"></a>ASCII 相容性</h3><p>標準庫中使用的標識符必須與 ASCII 相容，如 PEP 3131 的策略部分所述。</p>
<h3 id="套件和模組名稱"><a href="#套件和模組名稱" class="headerlink" title="套件和模組名稱"></a>套件和模組名稱</h3><p>模組應該有短的、全小寫的名稱。如果可以提高可讀性，可以在模組名稱中使用下劃線。 Python 套件也應該有短的、全小寫的名稱，儘管不鼓勵使用底線。</p>
<p>當用 C 或 C++ 編寫的擴充模組具有提供更高層級（例如更物件導向）介面的隨附 Python 模組時，C&#x2F;C++ 模組具有前導下劃線（例如<code>_socket</code>）。</p>
<h3 id="類別名"><a href="#類別名" class="headerlink" title="類別名"></a>類別名</h3><p>類別名稱通常應使用 CapWords 約定。</p>
<p>在介面被記錄並主要用作可呼叫的情況下，可以使用函數的命名約定。</p>
<p>請注意，內建名稱有一個單獨的約定：大多數內建名稱是單字（或兩個單字一起運行），CapWords 約定僅用於異常名稱和內建常數。</p>
<h3 id="類型變數名稱"><a href="#類型變數名稱" class="headerlink" title="類型變數名稱"></a>類型變數名稱</h3><p>PEP 484中引入的類型變數的名稱通常應使用大寫字母，優先使用短名稱：<code>T</code>, <code>AnyStr</code>, <code>Num</code>。建議在用於對應聲明協變或逆變行為的變數中加入<code>_co</code>後綴or ：<code>_contra</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from typing import TypeVar</span><br><span class="line"></span><br><span class="line">VT_co = TypeVar(<span class="string">&#x27;VT_co&#x27;</span>, covariant=True)</span><br><span class="line">KT_contra = TypeVar(<span class="string">&#x27;KT_contra&#x27;</span>, contravariant=True)</span><br></pre></td></tr></table></figure>
<h3 id="異常名稱"><a href="#異常名稱" class="headerlink" title="異常名稱"></a>異常名稱</h3><p>因為異常應該是類，所以這裡應用類別命名約定。但是，您應該在異常名稱上使用後綴“Error”（如果異常實際上是錯誤）。</p>
<h3 id="全域變數名稱"><a href="#全域變數名稱" class="headerlink" title="全域變數名稱"></a>全域變數名稱</h3><p>（我們希望這些變數只能在一個模組內使用。）這些約定與函數的約定大致相同。</p>
<p>設計用於 via 的模組應使用該機制來防止導出全域變量，或者使用舊的約定，在此類全域變數前添加下劃線前綴（您可能希望這樣做以指示這些全域變數是「模組非公用」）。<code>from M import *__all__</code></p>
<h3 id="函數和變數名稱"><a href="#函數和變數名稱" class="headerlink" title="函數和變數名稱"></a>函數和變數名稱</h3><p>函數名稱應小寫，必要時用底線分隔單字以提高可讀性。</p>
<p>變數名稱遵循與函數名稱相同的約定。</p>
<p>僅在已成為流行風格的上下文中（例如 threading.py）才允許使用混合大小寫，以保持向後相容性。</p>
<h3 id="函數和方法參數"><a href="#函數和方法參數" class="headerlink" title="函數和方法參數"></a>函數和方法參數</h3><p>始終用於<code>self</code>實例方法的第一個參數。</p>
<p>始終用於<code>cls</code>類別方法的第一個參數。</p>
<p>如果函數參數的名稱與保留關鍵字衝突，通常最好附加一個尾隨下劃線，而不是使用縮寫或拼字錯誤。因此<code>class_</code>優於<code>clss</code>. （也許更好的方法是使用同義詞來避免這種衝突。）</p>
<h3 id="方法名稱和實例變數"><a href="#方法名稱和實例變數" class="headerlink" title="方法名稱和實例變數"></a>方法名稱和實例變數</h3><p>使用函數命名規則：小寫，單字之間以底線分隔，以提高可讀性。</p>
<p>僅對非公共方法和實例變數使用一個前導下劃線。</p>
<p>為了避免與子類別發生名稱衝突，請使用兩個前導底線來呼叫 Python 的名稱修飾規則。</p>
<p>Python 將這些名稱與類別名稱混合在一起：如果類別 Foo 有一個名為 的屬性<code>__a</code>，則無法透過 存取它<code>Foo.__a</code>。 （堅持不懈的使用者仍然可以透過呼叫來獲得存取權限<code>Foo._Foo__a</code>。）通常，雙前導下劃線應該僅用於避免與設計為子類化的類別中的屬性發生名稱衝突。</p>
<p>注意：關於 <code>__names</code> 的使用存在一些爭議（見下文）。</p>
<h3 id="常數"><a href="#常數" class="headerlink" title="常數"></a>常數</h3><p>常數通常在模組層級定義，並全部用大寫字母書寫，並用下劃線分隔單字。範例包括 <code>MAX_OVERFLOW</code>和<code>TOTAL</code>。</p>
<h3 id="為繼承而設計"><a href="#為繼承而設計" class="headerlink" title="為繼承而設計"></a>為繼承而設計</h3><p>始終決定類別的方法和實例變數（統稱為“屬性”）應該是公共的還是非公共的。如有疑問，請選擇非公開；稍後將其公開比將公共屬性設為非公開更容易。</p>
<p>公共屬性是您期望與您的類別無關的客戶端使用的屬性，並承諾避免向後不相容的變更。非公共屬性是指那些不打算被第三方使用的屬性；您不保證非公共屬性不會更改甚至被刪除。</p>
<p>我們在這裡不使用術語“私有”，因為在 Python 中沒有屬性是真正私有的（通常不需要做不必要的工作）。</p>
<p>另一類屬性是「子類 API」的一部分（在其他語言中通常稱為「受保護」）。有些類別被設計為繼承、擴展或修改類別行為的各個方面。在設計這樣的類別時，請注意明確決定哪些屬性是公共的、哪些是子類別 API 的一部分以及哪些確實只能由基底類別使用。</p>
<p>考慮到這一點，以下是 Pythonic 指南：</p>
<ul>
<li><p>公共屬性不應有前導底線。</p>
</li>
<li><p>如果您的公共屬性名稱與保留關鍵字衝突，請在您的屬性名稱後面新增一個尾隨下劃線。這比縮寫或損壞的拼字更好。 （然而，儘管有這條規則，「cls」是任何已知為類別的變數或參數的首選拼寫，尤其是類別方法的第一個參數。）<br>註 1：有關類別方法，請參閱上面的參數名稱建議。</p>
</li>
<li><p>對於簡單的公共資料屬性，最好隻公開屬性名稱，而不需要複雜的存取器&#x2F;修改器方法。請記住，如果您發現簡單的資料屬性需要擴展功能行為，Python 提供了一條未來增強的簡單路徑。在這種情況下，請使用屬性將功能實作隱藏在簡單的資料屬性存取語法後面。<br>註 1：盡量保持功能行為沒有副作用，儘管快取等副作用通常是好的。</p>
</li>
</ul>
<p>註2：避免使用屬性進行計算量大的操作；屬性表示法使呼叫者相信訪問（相對）便宜。</p>
<ul>
<li>如果您的類別打算進行子類化，並且您有不希望子類別使用的屬性，請考慮使用雙前導下劃線命名它們，並且不使用尾隨下劃線。這會呼叫 Python 的名稱修飾演算法，其中類別的名稱被修飾為屬性名稱。如果子類別無意中包含具有相同名稱的屬性，這有助於避免屬性名稱衝突。<br>注意1：請注意，重整名稱中僅使用簡單的類別名稱，因此如果子類別選擇相同的類別名稱和屬性名稱，仍然可能會出現名稱衝突。</li>
</ul>
<p>註 2：名稱修改可能會使某些用途（例如除錯）變得 <code>__getattr__()</code>不太方便。然而，名稱修飾演算法有詳細記錄且易於手動執行。</p>
<p>註 3：並不是每個人都喜歡名稱修改。嘗試在避免意外名稱衝突的需要與高階呼叫者的潛在使用之間取得平衡。</p>
<h3 id="公共和內部介面"><a href="#公共和內部介面" class="headerlink" title="公共和內部介面"></a>公共和內部介面</h3><p>任何向後相容性保證僅適用於公共介面。因此，使用者能夠清楚地區分公共介面和內部介面非常重要。</p>
<p>記錄的接口被認為是公共的，除非文件明確聲明它們是臨時或內部接口，不受通常的向後相容性保證。所有未記錄的介面都應假定為內部介面。</p>
<p>為了更好地支援自省，模組應使用屬性在其公共 API 中明確聲明名稱<code>__all__</code>。設定<code> __all__</code>為空列表表示該模組沒有公共 API。</p>
<p>即使<code>__all__</code>設定正確，內部介面（套件、模組、類別、函數、屬性或其他名稱）仍應以單一前導底線為前綴。</p>
<p>如果任何包含命名空間（套件、模組或類別）被視為內部的，則介面也被視為內部的。</p>
<p>導入的名稱應始終被視為實作細節。其他模組不得依賴對此類導入名稱的間接訪問，除非它們是包含模組的 API 的明確記錄部分，例如os.path或公開子<code>__init__</code>模組功能的包模組。</p>
<h2 id="程式設計建議"><a href="#程式設計建議" class="headerlink" title="程式設計建議"></a>程式設計建議</h2><ul>
<li><p>程式碼的編寫方式不應損害 Python 的其他實作（PyPy、Jython、IronPython、Cython、Psyco 等）。<br>例如，不要依賴 CPython 對或形式的語句進行就地字串連接的高效實作。即使在 CPython 中，這種最佳化也很脆弱（它只適用於某些類型），並且在不使用引用計數的實作中根本不存在。在庫的效能敏感部分，應改用表單。這將確保在各種實作中串聯在線性時間內發生。<code>a += ba = a + b&#39;&#39;.join()</code></p>
</li>
<li><p>與像 None 這樣的單例的比較應該總是使用 isor來完成，而不是使用相等運算子。<code>is not</code><br>另外，當你真正想寫的時候要小心——例如，當測試預設為 None 的變數或參數是否被設定為其他值時。另一個值可能具有在布林上下文中可能為 false 的類型（例如容器）！<code>if xif x is not None</code></p>
</li>
<li><p>使用運算符而不是.雖然這兩個表達式在功能上相同，但前者更具可讀性和首選：is notnot … is</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> foo is not None:</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> not foo is None:</span><br></pre></td></tr></table></figure></li>
<li><p>當實作具有豐富比較的排序操作時，最好實作所有六個操作（<code>__eq__</code>、<code>__ne__</code>、 <code>__lt__</code>、<code>__le__</code>、<code>__gt__</code>、<code>__ge__</code>），而不是依賴其他程式碼僅執行特定比較。<br>為了最大限度地減少所涉及的工作量，functools.total_ordering() 裝飾器提供了一個工具來產生缺少的比較方法。</p>
</li>
</ul>
<p>PEP 207顯示Python 假定了自反性規則。因此，解釋器可以與、 和交換，並且可以交換和的參數。and運算保證使用運算符，而函數則使用 運算符。但是，最好實現所有六個操作，以便在其他上下文中不會出現混亂。<code>y &gt; xx &lt; yy &gt;= xx &lt;= yx == yx != ysort()min()&lt;max()&gt;</code></p>
<ul>
<li><p>始終使用 def 語句而不是將 lambda 表達式直接綁定到標識符的賦值語句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">def <span class="title function_">f</span><span class="params">(x)</span>: <span class="keyword">return</span> 2*x</span><br><span class="line"># Wrong:</span><br><span class="line">f = lambda x: <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>
<p>第一種形式意味著產生的函數物件的名稱具體為“f”，而不是通用的“<lambda>”。一般來說，這對於回溯和字串表示更有用。賦值語句的使用消除了 lambda 表達式相對於顯式 def 語句所能提供的唯一好處（即它可以嵌入到更大的表達式中）</p>
</li>
<li><p><code>Exception</code>從而不是派生異常<code>BaseException</code>。直接繼承 fromBaseException是為異常保留的，在這些異常中捕獲它們幾乎總是錯誤的做法。<br>根據 捕獲異常的程式碼可能需要的區別（而不是引發異常的位置）來設計異常層次結構。旨在回答「出了什麼問題？」的問題。以程式設計方式，而不是僅僅聲明「發生了問題」（有關內建異常層次結構的本課範例，請參閱PEP 3151 ）</p>
</li>
</ul>
<p>類別命名約定適用於此，但如果異常是錯誤，則應將後綴「Error」新增至異常類別。用於非本地流控製或其他形式的信令的非錯誤異常不需要特殊後綴。</p>
<ul>
<li><p>適當地使用異常鏈。 應用於指示明確替換而不丟失原始回溯。<code>raise X from Y</code><br>當有意取代內部異常（使用）時，請確保相關詳細資訊已轉移至新異常（例如將 <code>KeyError</code> 轉換為 <code>AttributeError</code> 時保留屬性名稱，或將原始異常的文字嵌入到新異常訊息中）。<code>raise X from None</code></p>
</li>
<li><p>捕捉異常時，請盡可能提及特定異常，而不是使用裸except:子句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    import platform_specific_module</span><br><span class="line">except ImportError:</span><br><span class="line">    platform_specific_module = None</span><br></pre></td></tr></table></figure>
<p>裸except:子句將捕捉 SystemExit 和 KeyboardInterrupt 異常，使使用 Control-C 中斷程式變得更加困難，並可能掩蓋其他問題。如果要捕獲表示程式錯誤的所有異常，請使用 (bare except 相當於)。<code>except Exception:except BaseException</code>:</p>
</li>
</ul>
<p>一個好的經驗法則是將純粹的「例外」子句的使用限制在兩種情況：</p>
<p>  1.異常處理程序是否將列印或記錄回溯；至少用戶會意識到發生了錯誤。<br>  2.如果程式碼需要執行一些清理工作，但隨後讓異常向上傳播<code>raise</code>。 <code>try...finally</code> 可能是處理這種情況的更好方法。<br>捕捉作業系統錯誤時，偏好 Python 3.3 中引入的明確異常層次結構，而不是<code>errno</code> 值的內省。<br>此外，對於所有 <code>try/ except</code> 子句，將該try子句限制為所需的絕對最小程式碼量。同樣，這可以避免掩蓋錯誤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">try:</span><br><span class="line">    value = collection[key]</span><br><span class="line">except KeyError:</span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> handle_value(value)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line">try:</span><br><span class="line">    # Too broad!</span><br><span class="line">    <span class="keyword">return</span> handle_value(collection[key])</span><br><span class="line">except KeyError:</span><br><span class="line">    # Will also catch KeyError raised by handle_value()</span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>當資源位於特定程式碼段的本地時，請使用語句 with來確保其在使用後得到及時可靠的清理。 try&#x2F;finally 語句也是可以接受的。<br>每當上下文管理器執行獲取和釋放資源以外的操作時，都應透過單獨的函數或方法來呼叫它們：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line">with conn.begin_transaction():</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br><span class="line"># Wrong:</span><br><span class="line">with conn:</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br></pre></td></tr></table></figure>
<p>後一個範例沒有提供任何資訊來表明<code>__enter__</code>和<code>__exit__</code>方法除了在事務後關閉連接之外正在執行其他操作。在這種情況下，明確很重要。</p>
</li>
<li><p>返回語句保持一致。函數中的所有 return 語句要么都應該返回表達式，要么都不應該返回。如果任何 return 語句傳回一個表達式，則任何不傳回值的 return 語句都應將其明確宣告為，且明確 return 語句應出現在函數結尾（如果可到達）：<code>return None</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"></span><br><span class="line">def <span class="title function_">foo</span><span class="params">(x)</span>:</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.<span class="built_in">sqrt</span>(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> None</span><br><span class="line"></span><br><span class="line">def bar(x):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> None</span><br><span class="line">    <span class="keyword">return</span> math.<span class="built_in">sqrt</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"></span><br><span class="line">def <span class="title function_">foo</span><span class="params">(x)</span>:</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.<span class="built_in">sqrt</span>(x)</span><br><span class="line"></span><br><span class="line">def bar(x):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> math.<span class="built_in">sqrt</span>(x)</span><br><span class="line">```    </span><br><span class="line">  * 使用`<span class="string">&#x27;&#x27;.startswith()`and`&#x27;</span><span class="string">&#x27;.endswith()`代替字串切片來檢查前綴或後綴。</span></span><br><span class="line"><span class="string">startswith() 和endswith() 更乾淨且更不容易出錯：</span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string"># Correct:</span></span><br><span class="line"><span class="string">if foo.startswith(&#x27;</span>bar<span class="number">&#x27;</span>):</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> foo[:<span class="number">3</span>] == <span class="string">&#x27;bar&#x27;</span>:</span><br></pre></td></tr></table></figure></li>
<li><p>物件類型比較應始終使用 isinstance() 而不是直接比較類型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">isinstance</span><span class="params">(obj, <span class="type">int</span>)</span>:</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">type</span><span class="params">(obj)</span> is <span class="title function_">type</span><span class="params">(<span class="number">1</span>)</span>:</span><br></pre></td></tr></table></figure></li>
<li><p>對於序列（字串、列表、元組），請使用空序列為 false 的事實：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> not seq:</span><br><span class="line"><span class="keyword">if</span> seq:</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">len</span><span class="params">(seq)</span>:</span><br><span class="line"><span class="keyword">if</span> not <span class="title function_">len</span><span class="params">(seq)</span>:</span><br></pre></td></tr></table></figure></li>
<li><p>不要寫依賴重要尾隨空格的字串文字。這種尾隨空白在視覺上是無法區分的，有些編輯器（或最近的reindent.py）會修剪它們。<br>請勿使用以下方法將布林值與 True 或 False 進行比較&#x3D;&#x3D;：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"><span class="keyword">if</span> greeting:</span><br><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> greeting == True:</span><br></pre></td></tr></table></figure>
<p>更差：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line"><span class="keyword">if</span> greeting is True:</span><br></pre></td></tr></table></figure></li>
<li><p><code>return</code>&#x2F;&#x2F;不<code>break</code>鼓勵<code>continue</code> 在 a 的finally 套件中使用流程控制語句<code>try...finally</code>，其中流程控制語句會跳到finally 套件之外。這是因為這樣的語句將隱式取消透過finally套件傳播的任何活動異常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Wrong:</span><br><span class="line">def <span class="title function_">foo</span><span class="params">()</span>:</span><br><span class="line">    try:</span><br><span class="line">        1 / 0</span><br><span class="line">    finally:</span><br><span class="line">        <span class="keyword">return</span> 42</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函數註釋"><a href="#函數註釋" class="headerlink" title="函數註釋"></a>函數註釋</h2><p>隨著PEP 484的接受，函數註解的樣式規則改變了。</p>
<ul>
<li><p>函數註解應使用PEP 484語法（上一節有一些註解的格式建議）。</p>
</li>
<li><p>不再鼓勵對本 PEP 中先前建議的註釋樣式進行實驗。</p>
</li>
<li><p>然而，在 stdlib 之外，現在鼓勵在PEP 484規則範圍內進行實驗。例如，使用PEP 484樣式類型註釋標記大型第三方庫或應用程序，檢查添加這些註釋的容易程度，並觀察它們的存在是否會提高程式碼的可理解性。</p>
</li>
<li><p>Python 標準函式庫在採用此類註解時應該保守，但它們的使用是允許用於新程式碼和大型重構的。</p>
</li>
<li><p>對於想要以不同方式使用函數註解的程式碼，建議新增以下形式的註解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># type: ignore</span></span><br></pre></td></tr></table></figure>
<p>靠近文件頂部；這告訴類型檢查器忽略所有註釋。 （可以在PEP 484中找到禁用類型檢查器投訴的更細粒度的方法。）</p>
</li>
<li><p>與 linter 一樣，類型檢查器是可選的獨立工具。預設情況下，Python 解釋器不應因類型檢查而發出任何訊息，也不應根據註釋改變其行為。</p>
</li>
<li><p>不想使用類型檢查器的使用者可以忽略它們。但是，預計第三方庫包的用戶可能希望對這些包運行類型檢查器。為此， PEP 484建議使用存根檔案：類型檢查器優先於相應的 .py 檔案讀取的 .pyi 檔案。存根檔案可以與庫一起分發，也可以透過 typeshed repo [5]單獨分發（在庫作者的許可下） 。</p>
</li>
</ul>
<h2 id="變數註釋"><a href="#變數註釋" class="headerlink" title="變數註釋"></a>變數註釋</h2><p>PEP 526引入了變數註解。對它們的風格建議與上面描述的函數註釋的風格建議類似：</p>
<ul>
<li>模組級變數、類別和實例變數以及局部變數的註解應在冒號後面有一個空格。</li>
<li>冒號之前不應有空格。</li>
<li>如果賦​​值有右側，則等號兩側應恰好有一個空格：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Correct:</span><br><span class="line"></span><br><span class="line">code: <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    coords: Tuple[<span class="type">int</span>, <span class="type">int</span>]</span><br><span class="line">    label: str = <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<pre><code class="c"># Wrong:

code:int  # No space after colon
code : int  # Space before colon

class Test:
    result: int=0  # No spaces around equality sign
</code></pre>
<p>儘管Python 3.6 接受PEP 526 ，但變數註釋語法是所有 Python 版本上存根檔案的首選語法（有關詳細信息，請參閱PEP 484）。<br>註腳</p>
<p>[ 1 ]<br>懸掛縮排是一種排版樣式，段落中除第一行外的所有行均縮排。在 Python 上下文中，該術語用於描述一種樣式，其中帶括號的語句的左括號是該行的最後一個非空白字符，後續行縮排直到右括號。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/05/troubleshooting/" rel="prev" title="Hexo 常見問題">
      <i class="fa fa-chevron-left"></i> Hexo 常見問題
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/15/blog-github/" rel="next" title="hexo blog發佈到github上">
      hexo blog發佈到github上 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%B4%B9"><span class="nav-number">1.</span> <span class="nav-text">介紹</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%84%9A%E8%A0%A2%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E5%B0%8F%E9%A0%AD%E8%85%A6%E7%9A%84%E6%83%A1%E9%AD%94"><span class="nav-number">2.</span> <span class="nav-text">愚蠢的一致性是小頭腦的惡魔</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E4%BD%88%E5%B1%80"><span class="nav-number">3.</span> <span class="nav-text">程式碼佈局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B8%AE%E6%8E%92"><span class="nav-number">3.1.</span> <span class="nav-text">縮排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%BD%E8%A1%A8%E7%AC%A6%E9%82%84%E6%98%AF%E7%A9%BA%E6%A0%BC%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">製表符還是空格？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%B7%9A%E8%B7%AF%E9%95%B7%E5%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">最大線路長度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%87%89%E8%A9%B2%E5%9C%A8%E4%BA%8C%E5%85%83%E9%81%8B%E7%AE%97%E5%AD%90%E4%B9%8B%E5%89%8D%E9%82%84%E6%98%AF%E4%B9%8B%E5%BE%8C%E6%8F%9B%E8%A1%8C%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">應該在二元運算子之前還是之後換行？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E8%A1%8C"><span class="nav-number">3.5.</span> <span class="nav-text">空行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%AA%94%E7%B7%A8%E7%A2%BC"><span class="nav-number">3.6.</span> <span class="nav-text">原始檔編碼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%B2%E5%8F%A3"><span class="nav-number">3.7.</span> <span class="nav-text">進口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%B5%84%E7%AD%89%E7%B4%9A-Dunder-%E5%90%8D%E7%A8%B1"><span class="nav-number">3.8.</span> <span class="nav-text">模組等級 Dunder 名稱</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E4%B8%B2%E5%BC%95%E8%99%9F"><span class="nav-number">4.</span> <span class="nav-text">字串引號</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E9%81%94%E5%BC%8F%E5%92%8C%E8%AA%9E%E5%8F%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="nav-number">5.</span> <span class="nav-text">表達式和語句中的空格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A8%8E%E5%8E%AD%E7%9A%84%E4%BA%8B"><span class="nav-number">5.1.</span> <span class="nav-text">討厭的事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AD%B0"><span class="nav-number">5.2.</span> <span class="nav-text">其他建議</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%95%E6%99%82%E4%BD%BF%E7%94%A8%E5%B0%BE%E9%9A%A8%E9%80%97%E8%99%9F"><span class="nav-number">6.</span> <span class="nav-text">何時使用尾隨逗號</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A9%95%E8%AB%96"><span class="nav-number">7.</span> <span class="nav-text">評論</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E8%A9%95%E8%AB%96"><span class="nav-number">7.1.</span> <span class="nav-text">阻止評論</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A7%E5%B5%8C%E8%A9%95%E8%AB%96"><span class="nav-number">7.2.</span> <span class="nav-text">內嵌評論</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E4%B8%B2"><span class="nav-number">7.3.</span> <span class="nav-text">文件字串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%B4%84%E5%AE%9A"><span class="nav-number">8.</span> <span class="nav-text">命名約定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%93%E5%80%92%E4%B8%80%E5%88%87%E7%9A%84%E5%8E%9F%E5%89%87"><span class="nav-number">8.1.</span> <span class="nav-text">壓倒一切的原則</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%80%A7%EF%BC%9A%E5%91%BD%E5%90%8D%E9%A2%A8%E6%A0%BC"><span class="nav-number">8.2.</span> <span class="nav-text">描述性：命名風格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%8F%E5%AE%9A%E6%80%A7%EF%BC%9A%E5%91%BD%E5%90%8D%E7%B4%84%E5%AE%9A"><span class="nav-number">8.3.</span> <span class="nav-text">規定性：命名約定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%89%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%90%8D%E5%AD%97"><span class="nav-number">8.3.1.</span> <span class="nav-text">應避免使用的名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII-%E7%9B%B8%E5%AE%B9%E6%80%A7"><span class="nav-number">8.3.2.</span> <span class="nav-text">ASCII 相容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E5%92%8C%E6%A8%A1%E7%B5%84%E5%90%8D%E7%A8%B1"><span class="nav-number">8.3.3.</span> <span class="nav-text">套件和模組名稱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%9E%E5%88%A5%E5%90%8D"><span class="nav-number">8.3.4.</span> <span class="nav-text">類別名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%9E%E5%9E%8B%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1"><span class="nav-number">8.3.5.</span> <span class="nav-text">類型變數名稱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%95%B0%E5%B8%B8%E5%90%8D%E7%A8%B1"><span class="nav-number">8.3.6.</span> <span class="nav-text">異常名稱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1"><span class="nav-number">8.3.7.</span> <span class="nav-text">全域變數名稱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B8%E5%92%8C%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1"><span class="nav-number">8.3.8.</span> <span class="nav-text">函數和變數名稱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B8%E5%92%8C%E6%96%B9%E6%B3%95%E5%8F%83%E6%95%B8"><span class="nav-number">8.3.9.</span> <span class="nav-text">函數和方法參數</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D%E7%A8%B1%E5%92%8C%E5%AF%A6%E4%BE%8B%E8%AE%8A%E6%95%B8"><span class="nav-number">8.3.10.</span> <span class="nav-text">方法名稱和實例變數</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E6%95%B8"><span class="nav-number">8.3.11.</span> <span class="nav-text">常數</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%BA%E7%B9%BC%E6%89%BF%E8%80%8C%E8%A8%AD%E8%A8%88"><span class="nav-number">8.3.12.</span> <span class="nav-text">為繼承而設計</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E5%92%8C%E5%85%A7%E9%83%A8%E4%BB%8B%E9%9D%A2"><span class="nav-number">8.3.13.</span> <span class="nav-text">公共和內部介面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%BB%BA%E8%AD%B0"><span class="nav-number">8.4.</span> <span class="nav-text">程式設計建議</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B8%E8%A8%BB%E9%87%8B"><span class="nav-number">8.5.</span> <span class="nav-text">函數註釋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%8A%E6%95%B8%E8%A8%BB%E9%87%8B"><span class="nav-number">8.6.</span> <span class="nav-text">變數註釋</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Robin Cheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robin Cheng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
